# -*- coding: utf-8 -*-
"""GROUPE ENERGIE

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VEZXkp9C0CMt88EsP8IB6EZsCG4GfQi9
"""

import pandas as pd

df = pd.read_csv("eco2mix-regional-cons-def.csv", delimiter= ";", low_memory=False)
# Problème sur la colone 9: Columns (9) have mixed types.
# Ajout du paramètre low_memory=False pour contourner le problème et permettre l'affichage du DF sans message d'erreur

# affichage de la première de chacune des 12 régions étudiées (les 12 enregistrement du 01-01-2013 à 00:00)
df.head(12)

# analyse des différents types de variables

print("nombre de lignes :", df.shape[0])
print("nombre de colonnes :", df.shape[1])
print()
print("----------------------------------------------------")
print("----------------------------------------------------")
print()
# il va falloir modifier les types de variable suivants:
# Date -> Date
# Eolien (MW) -> Float
# pour ce dernier, nous avons vu à l'étape précédente qu'il y a plusieurs types de variables,
# nous y reviendrons plus tard...

print("Types de variables")
display(df.info())

# Analyse de NA -calcul du % de NA par variables :
df_total = pd.DataFrame(df.isna().count()).reset_index()
df_total.columns = ['Variable', 'VALUE_COUNT']

df_na = pd.DataFrame(df.isna().sum()).reset_index()
df_na.columns = ['Variable', 'NA']

df_napercent = pd.DataFrame(df.isna().mean()*100).reset_index()
df_napercent.columns = ['Variable', 'NA%']

df_NA_analysis = pd.merge(df_total, df_na, on = "Variable", how = "inner")
df_NA_analysis = pd.merge(df_NA_analysis, df_napercent, on = "Variable", how = "inner")

display(df_NA_analysis)

# recherche de NaN de la variable 'Consommation (MW)'
df_conso = df[(df['Consommation (MW)'].isna())]
df_conso.head(12)

# il s'agit du premier enregistrement de chaque région daté du 01-01-2013 à 00:00, nous constatons que toutes les variables continues sont en NaN
# nous devons donc supprimer ces 12 enregistrements

df = df.iloc[12:]
df.head(12)

# Analyse des NaN de la variable 'Nucléaire (MW)' par région
df_nucleaire = df[(df['Nucléaire (MW)'].isna())]
display(df_nucleaire.groupby(['Région']).size().reset_index(name='Count'))

# les NaN concernent 5 régions qui ne disposent pas de centrales nucléaires pour produire de l'électricité
# nous pouvons donc corriger ces NaN en les remplaçant par des 0

df['Nucléaire (MW)'] = df['Nucléaire (MW)'].fillna(0)

# Analyse des NaN de la variable 'Pompage (MW)' par région
df_pompage = df[(df['Pompage (MW)'].isna())]
display(df_pompage.groupby(['Région']).size().reset_index(name='Count'))

# les NaN concernent 65 régions qui ne disposent pas de station de transfert d'énergie par pompage
# nous pouvons donc corriger ces NaN en les remplaçant par des 0

df['Pompage (MW)'] = df['Pompage (MW)'].fillna(0)

# Analyse des NaN des variables ['Stockage batterie','Déstockage batterie','Eolien terrestre','Eolien offshore']

## il y a 79.34% de NA soit 1 683 084 lignes sur 2 121 408

display(df[['Stockage batterie','Déstockage batterie','Eolien terrestre','Eolien offshore']].describe())
display(df[['Stockage batterie','Déstockage batterie','Eolien terrestre','Eolien offshore']].isna().sum())

## les 21% restants sont à 0
## -> colonnes à supprimer

# Suppression des 4 variables ['Stockage batterie','Déstockage batterie','Eolien terrestre','Eolien offshore']

df = df.drop(columns = ['Stockage batterie','Déstockage batterie','Eolien terrestre','Eolien offshore'])

# Analyse des NaN des variables TCO

colonnes_TCO = ['Région', 'TCO Nucléaire (%)', 'TCO Eolien (%)', 'TCO Solaire (%)', 'TCO Hydraulique (%)', 'TCO Bioénergies (%)']
df_TCO = df[colonnes_TCO].isna().astype(int)
df_TCO['Région'] = df['Région']

display(df_TCO.groupby(['Région']).size().reset_index(name='Count'))
# la distribution est indentique pour toutes les régions

# Correction du type de la variable 'Eolien (MW)
# Recherche et analyse des variables non numériques de la variable 'Eolien (MW)'

non_numeriques = df['Eolien (MW)'][pd.to_numeric(df['Eolien (MW)'], errors='coerce').isna()]
print(non_numeriques)
print()
print("Les valeurs non numériques sont :")
print(non_numeriques.value_counts())
print()
# les - utilisés à la place des des valeurs réelles
print("exemple ligne 207898 -> la valeur affichée et - au lieu de de sa valeur réelle")
print(df.loc[207898])

# Correction des anomalies dans la variable 'Eolien (MW)'
# la variable contient plusieurs types de données, nous ne pouvons donc pas effecter de calcul, il faut donc corriger cette erreur en procédant en plusieurs étapes

# on va d'abord remplacer les - par des une valeur aberrante qu'on ne retrouve pas dans la liste, par exemple -100, afin de pouvoir l'identifier par la suite
# vérifions que la valeur -100 n'existe pas
print(df['Eolien (MW)'][df['Eolien (MW)'] == '-100'])

# replaçons les - par -100
df['Eolien (MW)'] = df['Eolien (MW)'].replace("-", "-100")

# maintenant qu'il n'y a plus de valeurs alphanumériques, nous pouvons convertir le type de données
df['Eolien (MW)'] = df['Eolien (MW)'].astype('float')

# nous retrouvons bien 96 -100
print(df['Eolien (MW)'][df['Eolien (MW)'] == -100])

# nous pouvons enfin calculer la valeur réelle de production éolienne grace à la formule suivante :
# (consommation - production) - ech physique
# la variable 'Ech. physiques (MW)' indique le solde d'énergie entre consommation et production
# si le solde est négatif, la région a produit plus qu'elle n'a consommé et donc exporté vers les régions/pays voisins
# s'il est positif, la région a importé pour couvrir sa consommation
#
# si nous reprennons notre eexmple 207898
# nous constatons qu'il y a un delta de 657MW si nous comparons le solde conso-prod (-7160), et le solde des échanges physiques (-7817)
# -7817 - (2388-(77+9419+15+37))
print(df[['Consommation (MW)','Thermique (MW)','Nucléaire (MW)','Eolien (MW)','Solaire (MW)','Hydraulique (MW)','Pompage (MW)','Bioénergies (MW)','Ech. physiques (MW)']].loc[207898])

# calcul de la production sans énergie éolienne
prod_sans_eolien = df.loc[:, ['Thermique (MW)', 'Nucléaire (MW)', 'Solaire (MW)', 'Hydraulique (MW)', 'Bioénergies (MW)']].sum(axis=1)

# Utiliser une fonction lambda pour remplacer les valeurs -100 dans la colonne 'Eolien (MW)'
df['Eolien (MW)'] = df.apply(
    lambda row: (row['Consommation (MW)'] - prod_sans_eolien[row.name]) - row['Ech. physiques (MW)']
    if row['Eolien (MW)'] == -100 else row['Eolien (MW)'],
    axis=1)

# vérification
print(df[['Consommation (MW)','Thermique (MW)','Nucléaire (MW)','Eolien (MW)','Solaire (MW)','Hydraulique (MW)','Pompage (MW)','Bioénergies (MW)','Ech. physiques (MW)']].loc[207898])

# Revennons maintenant à la correction des NaN des variables TCO (Taux de COuverture)
# comme nous l'avons expliqué précédement, il s'agit de la production d'un mode de production / par la consommation
# cet indicateur cherche à connaitre la contribution de chaque mode de production par rapport à la consommation
# comme nous le montre l'exemple ci dessous :

#2121300
###################print(df[['Consommation (MW)','Thermique (MW)','TCO Thermique (%)']].loc[100])

# calcul des TCO manquants

# Remplacer les NaN dans la colonne 'TCO Thermique (%)' par 'Thermique (MW)' / 'Consommation (MW)'
###################df['TCO Thermique (%)'] = df.apply(lambda x: x['Thermique (MW)'] / x['Consommation (MW)'] * 100 if pd.isna(x['TCO Thermique (%)']) else x['TCO Thermique (%)'], axis=1)
###################df['TCO Nucléaire (%)'] = df.apply(lambda x: x['Nucléaire (MW)'] / x['Consommation (MW)'] * 100 if pd.isna(x['TCO Nucléaire (%)']) else x['TCO Nucléaire (%)'], axis=1)
###################df['TCO Eolien (%)'] = df.apply(lambda x: x['Eolien (MW)'] / x['Consommation (MW)'] * 100 if pd.isna(x['TCO Eolien (%)']) else x['TCO Eolien (%)'], axis=1)
###################df['TCO Solaire (%)'] = df.apply(lambda x: x['Solaire (MW)'] / x['Consommation (MW)'] * 100 if pd.isna(x['TCO Solaire (%)']) else x['TCO Solaire (%)'], axis=1)
###################df['TCO Hydraulique (%)'] = df.apply(lambda x: x['Hydraulique (MW)'] / x['Consommation (MW)'] * 100 if pd.isna(x['TCO Hydraulique (%)']) else x['TCO Hydraulique (%)'], axis=1)
###################df['TCO Bioénergies (%)'] = df.apply(lambda x: x['Bioénergies (MW)'] / x['Consommation (MW)'] * 100 if pd.isna(x['TCO Bioénergies (%)']) else x['TCO Bioénergies (%)'], axis=1)

# Analyse des NaN des variables TCH
###################df_pompage = df[(df['TCH Thermique (%)'].isna())]
###################display(df_pompage.groupby(['Année']).size().reset_index(name='Count'))

# pas de possibilité de calculer les données par nous-même
# correction par la moyenne ou la médiane non pertinente
# -> suppression des colonnes

###################df = df.drop(columns = ['TCH Thermique (%)', 'TCH Nucléaire (%)', 'TCH Eolien (%)', 'TCH Solaire (%)','TCH Hydraulique (%)','TCH Bioénergies (%)'])

# Analyse des NaN des variables TCO & TCH

# le TCO ou Taux de Couverture est la production pour un type de production / par la consommation
# nous pourrions donc les corriger nous même mais la pertinence de cette opération se pose,
# en effet, si notre objectif est de consolider les données au niveau du jour, il faudrait donc ensuite recalculer ces données
# la solution sera donc de supprimer ces données et de les recalculer au besoin directement dans Power BI

# Concernant les TCH ou Taux de CHarge, ils représentent la production rapportée à la puissance installée
# nous n'avons pas les éléments nécessaires pour corriger les valeurs car nous ne disposons pas de l'évolution de la puissance installée par jour et par région
# nous allons donc également supprimer ces données et utiliserons un second jeu de données pour analyser l'évolution de la capacité de production en France par année.


df = df.drop(columns = ['TCO Thermique (%)', 'TCO Nucléaire (%)', 'TCO Eolien (%)', 'TCO Solaire (%)','TCO Hydraulique (%)','TCO Bioénergies (%)',
                        'TCH Thermique (%)', 'TCH Nucléaire (%)', 'TCH Eolien (%)', 'TCH Solaire (%)','TCH Hydraulique (%)','TCH Bioénergies (%)'])

df

# Analyse des NaN de la variable Column30

## il y a 100% de NA

display(df['Column 30'].describe())
display(df['Column 30'].isna().sum())

## -> colonne à supprimer

df = df.drop(columns = ['Column 30'])

df

# Variables dates à modifier :

#3-Date             de    object    vers    date
#4-Heure            reste en format Object
#5-Date - Heure     colonne à supprimer
df["Date"] = pd.to_datetime(df['Date'])
df = df.drop(columns = ['Date - Heure'])

# création colonnes mois et années :
df['Année'] = df['Date'].apply(lambda x: pd.to_datetime(x).year)
df['Mois'] = df['Date'].apply(lambda x: pd.to_datetime(x).month)

display(df[['Date','Heure','Mois', 'Année']].info())
# -> type colonne 'Date' modifié et colonne 'Date - Heure' supprimée

"""i"""

# analyse variables qualitatives

display(df[['Code INSEE région','Région']].value_counts())
# 12 couples de valeurs CodeInsee / Région et une distribition identique entre toutes les variables

display(df['Nature'].value_counts())
# -> 2 valeurs différentes :
# "Données définitives" concerne les années clôturées
# "Données consolidées" pour l'année en cours de traitement

# Pas d'analyse pertinente à retirer de ces variables

# Synthèse des données par année et type de production

# consolidation des données sur l'année pour cadrage avec données officielles
df_heures_pleines = df.groupby(['Année']).agg({'Consommation (MW)': 'sum',
                                               'Thermique (MW)': 'sum',
                                               'Nucléaire (MW)': 'sum',
                                               'Eolien (MW)': 'sum',
                                               'Solaire (MW)': 'sum',
                                               'Hydraulique (MW)': 'sum',
                                               'Pompage (MW)': 'sum',
                                               'Bioénergies (MW)': 'sum',
                                               'Ech. physiques (MW)': 'sum'
                                        })
df_heures_pleines

# suite au cadrage des données réalisé avec les données de RTE, il s'avère que les données que nous utilisons doublonnent
# -> les demi-heures doivent être retirées, nous ne devons conserver que les heures pleines.
df = df[df['Heure'].str.endswith(":00")]

df_heures_pleines

df =  df.groupby(['Code INSEE région', 'Région', 'Nature', 'Date', 'Année', 'Mois']).agg({'Consommation (MW)': 'sum',
                                                                                          'Thermique (MW)': 'sum',
                                                                                          'Nucléaire (MW)': 'sum',
                                                                                          'Eolien (MW)': 'sum',
                                                                                          'Solaire (MW)': 'sum',
                                                                                          'Hydraulique (MW)': 'sum',
                                                                                          'Pompage (MW)': 'sum',
                                                                                          'Bioénergies (MW)': 'sum',
                                                                                          'Ech. physiques (MW)': 'sum'
                                                                                          }).reset_index()

df

# ajout d'une variable qui regroupe les productions des énergies renouvelables
df['Renouvelable (MW)'] = df['Eolien (MW)'] + df['Solaire (MW)'] + df['Hydraulique (MW)'] + df['Pompage (MW)'] + df['Bioénergies (MW)']
df['Total Production (MW)'] = df['Renouvelable (MW)'] + df['Thermique (MW)'] + df['Nucléaire (MW)']
df

from matplotlib import pyplot as plt

# Analyse de la production au niveau national (avec mise en évidence des 3 grands types de production) et phasage avec la conso

df_graph1 = df[['Année', 'Mois', 'Consommation (MW)', 'Thermique (MW)', 'Nucléaire (MW)', 'Renouvelable (MW)']].loc[df['Année'] < 2023]
df_graph1 = df_graph1.groupby(['Année', 'Mois']).sum().reset_index()
df_graph1['Thermique (MW)'] = df_graph1['Thermique (MW)'] / 1000
df_graph1['Nucléaire (MW)'] = df_graph1['Nucléaire (MW)'] / 1000
df_graph1['Renouvelable (MW)'] = df_graph1['Renouvelable (MW)'] / 1000
df_graph1['Consommation (MW)'] = df_graph1['Consommation (MW)'] / 1000
df_graph1['Année-Mois'] = df_graph1['Année'].astype(str) + '-' + df_graph1['Mois'].astype(str)

# Aires emplilées des productions
fig, ax = plt.subplots(figsize=(10, 6))
ax.stackplot(df_graph1['Année-Mois'],
             df_graph1['Nucléaire (MW)'],
             df_graph1['Renouvelable (MW)'],
             df_graph1['Thermique (MW)'],
             labels=['Production Nucléaire (GW)', 'Production Renouvelable (GW)', 'Production Thermique (GW)'])

# Courbe de la consommation
ax.plot(df_graph1['Année-Mois'], df_graph1['Consommation (MW)'], 'k--', label='Consommation (GW)')

ax.set_title('Phasage production et consommation d\'électricité au niveau national sur 10 années')
ax.set_xlabel('Année-Mois')
ax.set_ylabel('Puissance (GW)')
ax.legend(loc='lower left')
ax.grid(True)
plt.gca().spines[['top', 'right']].set_visible(False)
xticks = range(0, len(df_graph1['Année-Mois']), 12)
ax.set_xticks(xticks)
ax.set_xticklabels(df_graph1['Année-Mois'].iloc[xticks].apply(lambda x: x.split('-')[0]))

plt.show()

import matplotlib.pyplot as plt
import pandas as pd

# Exemple de création d'un DataFrame similaire pour test
# df = pd.read_csv('path_to_your_data.csv')

df_graph2 = df[['Code INSEE région', 'Région', 'Année', 'Mois', 'Consommation (MW)', 'Thermique (MW)', 'Nucléaire (MW)', 'Renouvelable (MW)']].loc[df['Année'] < 2023]
df_graph2 = df_graph2.groupby(['Code INSEE région', 'Région', 'Année', 'Mois']).sum().reset_index()
df_graph2['Thermique (MW)'] = df_graph2['Thermique (MW)'] / 1000
df_graph2['Nucléaire (MW)'] = df_graph2['Nucléaire (MW)'] / 1000
df_graph2['Renouvelable (MW)'] = df_graph2['Renouvelable (MW)'] / 1000
df_graph2['Consommation (MW)'] = df_graph2['Consommation (MW)'] / 1000
df_graph2['Année-Mois'] = df_graph2['Année'].astype(str) + '-' + df_graph2['Mois'].astype(str)

# Trouver les limites minimales et maximales des axes y
y_min = df_graph2[['Nucléaire (MW)', 'Renouvelable (MW)', 'Thermique (MW)', 'Consommation (MW)']].min().min()
y_max = df_graph2[['Nucléaire (MW)', 'Renouvelable (MW)', 'Thermique (MW)', 'Consommation (MW)']].max().max()

# Création de la figure avec sous-graphiques
fig, axes = plt.subplots(nrows=3, ncols=4, figsize=(20, 15))

fig.suptitle('Phasage production et consommation d\'électricité au niveau régional sur 10 années', fontsize=16)

# Liste des codes INSEE régions à afficher
codes_insee_regions = df_graph2['Code INSEE région'].unique()

for i, ax in enumerate(axes.flatten()):
    if i < len(codes_insee_regions):
        region_code = codes_insee_regions[i]
        df_graph2_region = df_graph2.loc[df_graph2['Code INSEE région'] == region_code]
        region_name = df_graph2_region['Région'].values[0]

        ax.stackplot(df_graph2_region['Année-Mois'],
                     df_graph2_region['Nucléaire (MW)'],
                     df_graph2_region['Renouvelable (MW)'],
                     df_graph2_region['Thermique (MW)'],
                     labels=['Production Nucléaire (GW)', 'Production Renouvelable (GW)', 'Production Thermique (GW)'])

        ax.plot(df_graph2_region['Année-Mois'], df_graph2_region['Consommation (MW)'], 'k--', label='Consommation (GW)')
        ax.set_title(f"{region_name}")
        ax.set_ylim(y_min, y_max)  # Appliquer les mêmes limites y à tous les graphiques
        ax.grid(True)
        ax.spines[['top', 'right']].set_visible(False)
        xticks = range(0, len(df_graph2_region['Année-Mois']), 12)
        ax.set_xticks(xticks)
        ax.set_xticklabels(df_graph2_region['Année-Mois'].iloc[xticks].apply(lambda x: x.split('-')[0]))

# Ajustement des espacements et affichage de la légende globale
handles, labels = ax.get_legend_handles_labels()
fig.legend(handles, labels, loc='upper center', ncol=3, bbox_to_anchor=(0.5, -0.05))
plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()

# Ajout d'une nouvelle variable qualitative liée à l'analyse précédente :
# profil de région
# Fortement dépendante -> Ile de France
# Dépendante -> Bourgogne-Franche-Comté, Pays de la Loire, Bretagne, Provence-Alpes-Côte d'Azur
# Equilibre -> Hauts de France, Nouvelle-Acquitaine, Occitanie
# Indépendante -> Centre-Val de Loire, Normandie, Grand Est, Auvergne-Rhônes-Alpes

df['Profil région'] = df['Région'].apply(lambda x: 'Fortement dépendante' if x == 'Île-de-France' else (
                                                   'Dépendante' if x in ('Bourgogne-Franche-Comté', 'Pays de la Loire', 'Bretagne', 'Provence-Alpes-Côte d\'Azur') else (
                                                   'A l\'équilibre' if x in ('Hauts-de-France', 'Nouvelle-Aquitaine', 'Occitanie') else (
                                                   'Indépendante'
                                        ))))
df

df2 = df[['Année', 'Mois', 'Région', 'Consommation (MW)']]
df2 = df2.groupby(['Année', 'Mois', 'Région']).sum().reset_index()

# Définir les régions
regions = df2['Région'].unique()

# Créer une grille de 3x4 pour les graphiques
fig, axes = plt.subplots(nrows=3, ncols=4, figsize=(20, 10))
axes = axes.flatten()

# Liste pour stocker les handles pour la légende globale
handles, labels = [], []

# Tracer les graphiques pour chaque région
for ax, region in zip(axes, regions):
    region_data = df2[df2['Région'] == region]
    pivot_table = region_data.pivot(index='Mois', columns='Année', values='Consommation (MW)')

    for col in pivot_table.columns:
        line, = ax.plot(pivot_table.index, pivot_table[col], label=f'Année {col}')
        if not handles:  # Stocker les handles et labels pour la première région uniquement
            handles.append(line)
            labels.append(f'Année {col}')

    ax.set_title(region)
    ax.set_xlabel('Mois')
    ax.set_ylabel('Consommation (MW)')
    ax.grid(True)

    # Définir les ticks et labels des mois sur l'axe des x
    ax.set_xticks(range(1, 13))
    ax.set_xticklabels(['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])

# Supprimer les axes vides
for i in range(len(regions), len(axes)):
    fig.delaxes(axes[i])

# Ajouter une légende globale
fig.legend(handles, labels, loc='upper center', bbox_to_anchor=(0.5, 1.05), ncol=len(handles))

plt.tight_layout(rect=[0, 0, 1, 0.95])
plt.show()

df2 = df[['Année', 'Mois', 'Région', 'Consommation (MW)']]
df2 = df2.groupby(['Année', 'Mois', 'Région']).sum().reset_index()
df2

from matplotlib import pyplot as plt

# Analyse de la production au niveau national (avec mise en évidence des 3 grands types de production) et phasage avec la conso


df_graph3 = df[['Année', 'Mois', 'Consommation (MW)', 'Ech. physiques (MW)', 'Total Production (MW)']].loc[df['Année'] < 2023]
df_graph3 = df_graph3.groupby(['Année', 'Mois']).sum().reset_index()
df_graph3['Ech. physiques (MW)'] = df_graph3['Ech. physiques (MW)'] / 1000
df_graph3['Total Production (MW)'] = df_graph3['Total Production (MW)'] / 1000
df_graph3['Consommation (MW)'] = df_graph3['Consommation (MW)'] / 1000
df_graph3['Année-Mois'] = df_graph3['Année'].astype(str) + '-' + df_graph3['Mois'].astype(str)

# Aires emplilées des productions
fig, ax = plt.subplots(figsize=(10, 6))
ax.stackplot(df_graph3['Année-Mois'],
             df_graph3['Ech. physiques (MW)'],
             labels=['Ech. physiques (GW)'])

# Courbe de la consommation
#ax.plot(df_graph3['Année-Mois'], df_graph3['Consommation (MW)'], 'k--', label='Consommation (GW)')
positive = df_graph3['Ech. physiques (MW)'].clip(lower=0)
negative = df_graph3['Ech. physiques (MW)'].clip(upper=0)
ax.fill_between(df_graph3['Année-Mois'], positive, color='red', label='Import électricité (GW)')
ax.fill_between(df_graph3['Année-Mois'], negative, color='green', label='Export électricité (GW)')

ax.set_title('Solde national import / export d\'électricité sur 10 années')
ax.set_xlabel('Année-Mois')
ax.set_ylabel('Puissance (GW)')
ax.legend(loc='lower left')
ax.grid(True)
plt.gca().spines[['top', 'right']].set_visible(False)
xticks = range(0, len(df_graph3['Année-Mois']), 12)
ax.set_xticks(xticks)
ax.set_xticklabels(df_graph3['Année-Mois'].iloc[xticks].apply(lambda x: x.split('-')[0]))

plt.show()

df_graph4 = df[['Code INSEE région', 'Région', 'Année', 'Mois', 'Consommation (MW)', 'Ech. physiques (MW)', 'Total Production (MW)']].loc[df['Année'] < 2023]
df_graph4 = df_graph4.groupby(['Code INSEE région', 'Région', 'Année', 'Mois']).sum().reset_index()
df_graph4['Ech. physiques (MW)'] = df_graph4['Ech. physiques (MW)'] / 1000
df_graph4['Total Production (MW)'] = df_graph4['Total Production (MW)'] / 1000
df_graph4['Consommation (MW)'] = df_graph4['Consommation (MW)'] / 1000
df_graph4['TCO Total (GW)'] = df_graph4['Total Production (MW)'] / df_graph4['Consommation (MW)']
df_graph4['Année-Mois'] = df_graph4['Année'].astype(str) + '-' + df_graph4['Mois'].astype(str)

# Trouver les limites minimales et maximales des axes y
y_min = df_graph4[['Ech. physiques (MW)']].min().min()
y_max = df_graph4[['Ech. physiques (MW)']].max().max()

# Création de la figure avec sous-graphiques
fig, axes = plt.subplots(nrows=3, ncols=4, figsize=(20, 15))
fig.suptitle('Solde régionnal import / export d\'électricité sur 10 années', fontsize=16)

# Liste des codes INSEE régions à afficher
codes_insee_regions = df_graph4['Code INSEE région'].unique()
for i, ax in enumerate(axes.flatten()):
  if i < len(codes_insee_regions):
    region_code = codes_insee_regions[i]
    df_graph4_region = df_graph4.loc[df_graph4['Code INSEE région'] == region_code]
    region_name = df_graph4_region['Région'].values[0]
    # Séparation des valeurs positives et négatives
    positive = df_graph4_region['Ech. physiques (MW)'].clip(lower=0)
    negative = df_graph4_region['Ech. physiques (MW)'].clip(upper=0)
    ax.fill_between(df_graph4_region['Année-Mois'], positive, color='red', label='Import électricité (GW)')
    ax.fill_between(df_graph4_region['Année-Mois'], negative, color='green', label='Export électricité (GW)')

    ax.set_title(f"{region_name}")
    ax.set_ylim(y_min, y_max)
    # Appliquer les mêmes limites y à tous les graphiques
    ax.grid(True)
    ax.spines[['top', 'right']].set_visible(False)
    xticks = range(0, len(df_graph4_region['Année-Mois']), 12)
    ax.set_xticks(xticks)
    ax.set_xticklabels(df_graph4_region['Année-Mois'].iloc[xticks].apply(lambda x: x.split('-')[0]))

# Ajustement des espacements et affichage de la légende globale
handles, labels = ax.get_legend_handles_labels()
fig.legend(handles, labels, loc='upper center', ncol=3, bbox_to_anchor=(0.5, -0.05))
plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()

df_parc_region = pd.read_csv("parc-region-annuel-production-filiere.csv", delimiter= ";")

df_parc_region = df_parc_region.fillna(0)


df_prod_region = df[['Thermique (MW)','Nucléaire (MW)','Eolien (MW)','Solaire (MW)','Hydraulique (MW)','Pompage (MW)','Bioénergies (MW)', 'Année', 'Code INSEE région', 'Région']].loc[df['Année'] < 2023].groupby(['Année', 'Code INSEE région','Région']).sum()
df_prod_region['Thermique (MW)'] = df_prod_region['Thermique (MW)'] / 1000
df_prod_region['Nucléaire (MW)'] = df_prod_region['Nucléaire (MW)'] / 1000
df_prod_region['Eolien (MW)'] = df_prod_region['Eolien (MW)'] / 1000
df_prod_region['Solaire (MW)'] = df_prod_region['Solaire (MW)'] / 1000
df_prod_region['Hydraulique (MW)'] = df_prod_region['Hydraulique (MW)'] / 1000
df_prod_region['Pompage (MW)'] = df_prod_region['Pompage (MW)'] / 1000
df_prod_region['Bioénergies (MW)'] = df_prod_region['Bioénergies (MW)'] / 1000
new_names = {
    'Thermique (MW)': 'Production thermique (GW)',
    'Nucléaire (MW)': 'Production nucléaire (GW)',
    'Solaire (MW)': 'Production solaire (GW)',
    'Eolien (MW)': 'Production éolien (GW)',
    'Hydraulique (MW)': 'Production hydraulique (GW)',
    'Pompage (MW)': 'Production pompage (GW)',
    'Bioénergies (MW)': 'Production bioénergies (GW)'
}
df_prod_region.rename(columns=new_names, inplace=True)

df_region = pd.merge(df_parc_region, df_prod_region, on = ['Année', 'Code INSEE région'])
df_region

# Agréger les données par année
df_graph1 = df_parc_region.groupby('Année').sum().reset_index()
df_graph1 = df_graph1.loc[(df_graph1['Année'] >= 2013) & (df_graph1['Année'] < 2023)]

# Créer le graphique
fig, ax = plt.subplots(figsize=(10, 6))

ax.stackplot(df_graph1['Année'],
             df_graph1['Parc nucléaire (MW)'],
             df_graph1['Parc thermique fossile (MW)'],
             df_graph1['Parc hydraulique (MW)'],
             df_graph1['Parc éolien (MW)'],
             df_graph1['Parc solaire (MW)'],
             df_graph1['Parc bioénergies (MW)'],
             labels=['Parc nucléaire (MW)', 'Parc thermique fossile (MW)', 'Parc hydraulique (MW)', 'Parc éolien (MW)', 'Parc solaire (MW)', 'Parc bioénergies (MW)'])

ax.set_title('Évolution du mix électrique français')
ax.set_xlabel('Année')
ax.set_ylabel('Capacité (MW)')
ax.legend(loc='lower left')
ax.grid(True)

# Agréger les données par année
df_graph2 = df_parc_region.groupby('Année').sum().reset_index()
df_graph2 = df_graph2.loc[(df_graph2['Année'] >= 2013) & (df_graph2['Année'] < 2023)]

# Définir les types de production
types_production = [
    'Parc nucléaire (MW)',
    'Parc thermique fossile (MW)',
    'Parc hydraulique (MW)',
    'Parc éolien (MW)',
    'Parc solaire (MW)',
    'Parc bioénergies (MW)'
]

# Créer les graphiques en barres pour chaque type de production
fig, axes = plt.subplots(nrows=2, ncols=3, figsize=(18, 10))

for ax, col in zip(axes.flatten(), types_production):
    ax.bar(df_graph2['Année'], df_graph2[col], label=col)
    ax.set_title(col)
    ax.set_xlabel('Année')
    ax.set_ylabel('Capacité (MW)')
    ax.grid(True)

    ax.legend()

fig.suptitle('Évolution du mix électrique français par type de production')
plt.tight_layout(rect=[0, 0.03, 1, 0.95])
#ax.legend(loc='lower left')#
plt.show()

import matplotlib.pyplot as plt
import pandas as pd

# Agréger les données par année
df_graph3 = df_region.groupby('Année').sum().reset_index()
df_graph3 = df_graph3.loc[(df_graph3['Année'] >= 2013) & (df_graph3['Année'] < 2023)]

# Définir les types de production
parc_installe = [
    'Parc nucléaire (MW)',
    'Parc thermique fossile (MW)',
    'Parc hydraulique (MW)',
    'Parc éolien (MW)',
    'Parc solaire (MW)',
    'Parc bioénergies (MW)'
]

production_gw = [
    'Production nucléaire (GW)',
    'Production thermique (GW)',
    'Production hydraulique (GW)',
    'Production éolien (GW)',
    'Production solaire (GW)',
    'Production bioénergies (GW)'
]

fig, axes = plt.subplots(nrows=2, ncols=3, figsize=(18, 8))

for ax, col, col_gw in zip(axes.flatten(), parc_installe, production_gw):
    ax.bar(df_graph3['Année'] - 0.2, df_graph3[col], width=0.4, label='Puissance Installée')
    ax2 = ax.twinx()
    ax2.bar(df_graph3['Année'] + 0.2, df_graph3[col_gw], width=0.4, color='orange', label='Production')

    ax.set_title(col)
    ax.set_xlabel('Année')
    ax.set_ylabel('Capacité (MW)')
    ax2.set_ylabel('Production (GW)', color='orange')
    ax.grid(True)

# Combiner les légendes
handles1, labels1 = ax.get_legend_handles_labels()
handles2, labels2 = ax2.get_legend_handles_labels()

fig.legend(handles1 + handles2, ['Puissance Installée', 'Production'], loc='upper center', bbox_to_anchor=(0.5, -0.05), ncol=4)
fig.suptitle('Évolution du mix électrique et de la production d\'électricité en France par type de production')
plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()

"import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
import matplotlib.patches as mpatches

# Agréger les données par année
df_graph4 = df_region.groupby('Année').sum().reset_index()
df_graph4 = df_graph4.loc[(df_graph4['Année'] >= 2013) & (df_graph4['Année'] < 2023)]

# Définir les types de production
parc_installe = [
    'Parc nucléaire (MW)',
    'Parc thermique fossile (MW)',
    'Parc hydraulique (MW)',
    'Parc éolien (MW)',
    'Parc solaire (MW)',
    'Parc bioénergies (MW)'
]

production_gw = [
    'Production nucléaire (GW)',
    'Production thermique (GW)',
    'Production hydraulique (GW)',
    'Production éolien (GW)',
    'Production solaire (GW)',
    'Production bioénergies (GW)'
]

# Créer une colormap
cmap = plt.get_cmap("viridis")
norm = plt.Normalize(df_graph4['Année'].min(), df_graph4['Année'].max())
colors = cmap(norm(df_graph4['Année']))

fig, axes = plt.subplots(nrows=2, ncols=3, figsize=(18, 10))

for ax, col, col_gw in zip(axes.flatten(), parc_installe, production_gw):
    sc = ax.scatter(df_graph4[col], df_graph4[col_gw], c=colors)

    # Ajuster une courbe de tendance
    X = df_graph4[col].values.reshape(-1, 1)
    y = df_graph4[col_gw].values
    model = LinearRegression().fit(X, y)
    trendline = model.predict(X)
    ax.plot(df_graph4[col], trendline, color='red', linestyle='--', linewidth=2)

    ax.set_title(f'{col} vs {col_gw}')
    ax.set_xlabel('Capacité (MW)')
    ax.set_ylabel('Production (GW)')
    ax.grid(True)

# Créer une légende personnalisée avec les années et leurs couleurs correspondantes
handles = [mpatches.Patch(color=cmap(norm(year)), label=str(year)) for year in df_graph4['Année']]
fig.legend(handles=handles, title="Années", bbox_to_anchor=(1.05, 0.5), loc='center left', borderaxespad=0.)

fig.suptitle('Relation entre la puissance installée et la production par type d\'énergie avec courbes de tendances')
plt.tight_layout(rect=[0, 0, 1, 0.95])
plt.show()

import seaborn as sns

# Définir la colonne 'Région' comme index
df_graph5 = df_region[['Année', 'Région', 'Production bioénergies (GW)', 'Production thermique (GW)', 'Production solaire (GW)', 'Production éolien (GW)', 'Production hydraulique (GW)', 'Production nucléaire (GW)']].loc[(df_region['Année'] == 2013)]

df_graph5['Production thermique (GW)'] = df_graph5['Production thermique (GW)'] / 1000
df_graph5['Production nucléaire (GW)'] = df_graph5['Production nucléaire (GW)'] / 1000
df_graph5['Production éolien (GW)'] = df_graph5['Production éolien (GW)'] / 1000
df_graph5['Production solaire (GW)'] = df_graph5['Production solaire (GW)'] / 1000
df_graph5['Production hydraulique (GW)'] = df_graph5['Production hydraulique (GW)'] / 1000
df_graph5['Production bioénergies (GW)'] = df_graph5['Production bioénergies (GW)'] / 1000
new_names = {
    'Production thermique (GW)': 'Production thermique (TW)',
    'Production nucléaire (GW)': 'Production nucléaire (TW)',
    'Production éolien (GW)': 'Production éolien (TW)',
    'Production solaire (GW)': 'Production solaire (TW)',
    'Production hydraulique (GW)': 'Production hydraulique (TW)',
    'Production bioénergies (GW)': 'Production bioénergies (TW)'
}
df_graph5.rename(columns=new_names, inplace=True)

df_graph5 = df_graph5[['Région', 'Production bioénergies (TW)', 'Production solaire (TW)', 'Production éolien (TW)', 'Production thermique (TW)', 'Production hydraulique (TW)', 'Production nucléaire (TW)']]
df_graph5.set_index('Région', inplace=True)

# Créer la heatmap
plt.figure(figsize=(10, 6))
sns.heatmap(df_graph5, annot=True, fmt=".2f", cmap='viridis', cbar_kws={'label': 'TW'})
plt.title('Production d\'énergie par région et par mode de production - 2022')
plt.show()

import plotly.express as px
import plotly.graph_objects as go
import pandas as pd

# Empiler les données pour obtenir un format long
df_region_ = df_region[['Année', 'Région', 'Production bioénergies (GW)', 'Production thermique (GW)', 'Production solaire (GW)', 'Production éolien (GW)', 'Production hydraulique (GW)', 'Production nucléaire (GW)']]
df_long = df_region_.melt(id_vars=['Année', 'Région'], var_name='Mode de production', value_name='GW')

# Créer des frames pour chaque année
frames = []
for year in sorted(df_long['Année'].unique()):
    frame = df_long[df_long['Année'] == year].pivot(index='Région', columns='Mode de production', values='GW')
    frames.append(go.Frame(data=[go.Heatmap(
        z=frame.values,
        x=frame.columns,
        y=frame.index,
        colorscale='Viridis',
        zmin=0, zmax=df_long['GW'].max())],
        name=str(year)
    ))

# Créer la figure initiale
initial_frame = df_long[df_long['Année'] == sorted(df_long['Année'].unique())[0]].pivot(index='Région', columns='Mode de production', values='GW')

fig = go.Figure(data=go.Heatmap(
    z=initial_frame.values,
    x=initial_frame.columns,
    y=initial_frame.index,
    colorscale='Viridis',
    zmin=0, zmax=df_long['GW'].max()),
    frames=frames
)

# Ajouter le slider pour les années
sliders = [{
    'steps': [{
        'method': 'animate',
        'label': str(year),
        'args': [[str(year)], {'frame': {'duration': 10, 'redraw': True}, 'mode': 'immediate'}]
    } for year in sorted(df_long['Année'].unique())],
    'transition': {'duration': 10},
    'x': 0.1,
    'len': 0.9
}]

fig.update_layout(
    title="Production d'énergie par région et par mode de production",
    xaxis_title="Mode de production",
    yaxis_title="Région",
    sliders=sliders
)

fig.show()

#enregistrement des fichiers csv

df.to_csv('Jeu de données principal.csv', index=False)
df_region.to_csv('Jeu de données secondaire.csv', index=False)



"""# Nouvelle section

**Reasoning**:
Load the "eco2mix-regional-cons-def.csv" file into a pandas DataFrame and display the first 5 rows.
"""

import pandas as pd

try:
    df = pd.read_csv('eco2mix-regional-cons-def.csv')
    display(df.head())
except FileNotFoundError:
    print("Error: 'eco2mix-regional-cons-def.csv' not found.")
    df = None

"""## Data exploration

### Subtask:
Explore the loaded data to understand its characteristics.

**Reasoning**:
The data needs to be properly parsed due to the semicolon delimiter and the single column issue.  I'll explore the data's characteristics after fixing this.
"""

import pandas as pd

# Fix the dataframe
try:
    df = pd.read_csv('eco2mix-regional-cons-def.csv', sep=';')
    display(df.head())
    print(df.shape)
    print(df.info())
    display(df.describe())
    print(df.isnull().sum() / len(df) * 100)
    for col in ['Région', 'Nature']:
        print(f'\nUnique values for {col}:')
        print(df[col].unique())
    print(f'\nEarliest date: {df["Date"].min()}')
    print(f'Latest date: {df["Date"].max()}')
except Exception as e:
    print(f"An error occurred: {e}")

"""## Data cleaning

### Subtask:
Clean the data by handling missing values and converting data types.

**Reasoning**:
Handle missing values, convert data types, and address outliers and inconsistencies as per the instructions.
"""

import pandas as pd
import numpy as np

# Convert 'Date' column to datetime
df['Date'] = pd.to_datetime(df['Date'], format='%Y-%m-%d', errors='coerce')

# Convert 'Eolien (MW)' to numeric, coercing errors to NaN
df['Eolien (MW)'] = pd.to_numeric(df['Eolien (MW)'], errors='coerce')

# Drop the empty column
df = df.drop(columns=['Column 30'])

# Handle missing values (using mean for numeric, mode for categorical)
numeric_cols = df.select_dtypes(include=np.number).columns
for col in numeric_cols:
    df[col] = df[col].fillna(df[col].mean())

categorical_cols = ['Région', 'Nature']
for col in categorical_cols:
    df[col] = df[col].fillna(df[col].mode()[0])

# Outlier handling: Cap values for 'Pompage (MW)' and 'TCH Hydraulique (%)'
df['Pompage (MW)'] = np.clip(df['Pompage (MW)'], df['Pompage (MW)'].quantile(0.01), df['Pompage (MW)'].quantile(0.99))
df['TCH Hydraulique (%)'] = np.clip(df['TCH Hydraulique (%)'], df['TCH Hydraulique (%)'].quantile(0.01), df['TCH Hydraulique (%)'].quantile(0.99))

# Remove duplicate rows (if any)
df.drop_duplicates(inplace=True)

display(df.head(12))
display(df.info())

"""## Data wrangling

### Subtask:
Prepare the data for analysis by creating new features and aggregating data to a daily level.

**Reasoning**:
Calculate the total energy consumption per region per day, calculate the percentage contribution of each energy source, and aggregate the data to a daily level.
"""

import pandas as pd
import numpy as np

# Calculate total consumption per region per day
df['TotalConsommationRegion'] = df.groupby(['Région', 'Date'])['Consommation (MW)'].transform('sum')

# Calculate percentage contribution of each energy source
energy_sources = ['Eolien', 'Nucleaire', 'Solaire', 'Hydraulique', 'Bioénergies', 'Thermique']
for source in energy_sources:
    df[f'{source}%'] = np.where(df['TotalConsommationRegion'] != 0, (df[f'{source} (MW)'] / df['TotalConsommationRegion']) * 100, 0)

# Aggregate data to daily level
aggregation_functions = {
    'TotalConsommationRegion': 'sum',
    'Consommation (MW)': 'sum',
    'Thermique (MW)': 'sum',
    'Nucléaire (MW)': 'sum',
    'Eolien (MW)': 'sum',
    'Solaire (MW)': 'sum',
    'Hydraulique (MW)': 'sum',
    'Bioénergies (MW)': 'sum',
    'Eolien%': 'mean',
    'Nucleaire%': 'mean',
    'Solaire%': 'mean',
    'Hydraulique%': 'mean',
    'Bioénergies%': 'mean',
    'Thermique%': 'mean'
}

df_daily = df.groupby(['Région', 'Date']).agg(aggregation_functions).reset_index()

display(df_daily.head())

"""**Reasoning**:
The previous code failed due to a KeyError for 'Nucleaire (MW)'.  The column name in the dataframe is 'Nucléaire (MW)', not 'Nucleaire (MW)'.  Correct the column name in the code and rerun the aggregation.


"""

import pandas as pd
import numpy as np

# Calculate total consumption per region per day
df['TotalConsommationRegion'] = df.groupby(['Région', 'Date'])['Consommation (MW)'].transform('sum')

# Calculate percentage contribution of each energy source
energy_sources = ['Eolien', 'Nucléaire', 'Solaire', 'Hydraulique', 'Bioénergies', 'Thermique']
for source in energy_sources:
    df[f'{source}%'] = np.where(df['TotalConsommationRegion'] != 0, (df[f'{source} (MW)'] / df['TotalConsommationRegion']) * 100, 0)

# Aggregate data to daily level
aggregation_functions = {
    'TotalConsommationRegion': 'sum',
    'Consommation (MW)': 'sum',
    'Thermique (MW)': 'sum',
    'Nucléaire (MW)': 'sum',
    'Eolien (MW)': 'sum',
    'Solaire (MW)': 'sum',
    'Hydraulique (MW)': 'sum',
    'Bioénergies (MW)': 'sum',
    'Eolien%': 'mean',
    'Nucléaire%': 'mean',
    'Solaire%': 'mean',
    'Hydraulique%': 'mean',
    'Bioénergies%': 'mean',
    'Thermique%': 'mean'
}

df_daily = df.groupby(['Région', 'Date']).agg(aggregation_functions).reset_index()

display(df_daily.head())

"""## Data visualization

### Subtask:
Visualize key trends and patterns in the daily energy consumption data.

**Reasoning**:
Visualize the key trends and patterns in the daily energy consumption data using line plots, stacked area charts, and bar charts.
"""

import matplotlib.pyplot as plt

# Line plot of total daily energy consumption over time for each region
plt.figure(figsize=(15, 6))
for region in df_daily['Région'].unique():
    region_data = df_daily[df_daily['Région'] == region]
    plt.plot(region_data['Date'], region_data['TotalConsommationRegion'], label=region)
plt.xlabel('Date')
plt.ylabel('Total Daily Energy Consumption (MW)')
plt.title('Trend of Total Daily Energy Consumption by Region')
plt.legend()
plt.grid(True)
plt.show()

# Stacked area chart for a representative region (e.g., 'Île-de-France')
region_to_plot = 'Île-de-France'
region_data = df_daily[df_daily['Région'] == region_to_plot]
plt.figure(figsize=(15, 6))
sources_to_plot = ['Eolien%', 'Nucléaire%', 'Solaire%', 'Hydraulique%', 'Bioénergies%', 'Thermique%']
plt.stackplot(region_data['Date'], region_data[sources_to_plot].values.T, labels=sources_to_plot)
plt.xlabel('Date')
plt.ylabel('Percentage Contribution')
plt.title(f'Energy Source Contribution in {region_to_plot}')
plt.legend(loc='upper left')
plt.grid(True)
plt.show()

# Bar chart comparing average daily energy consumption across regions
plt.figure(figsize=(12, 6))
average_consumption = df_daily.groupby('Région')['TotalConsommationRegion'].mean()
average_consumption.plot(kind='bar', color='skyblue')
plt.xlabel('Region')
plt.ylabel('Average Daily Energy Consumption (MW)')
plt.title('Average Daily Energy Consumption by Region')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.grid(axis='y')
plt.show()

"""## Data analysis

### Subtask:
Analyze the daily energy consumption data to identify correlations, seasonal trends, and significant changes over time.

**Reasoning**:
Calculate the correlation matrix for relevant numerical columns in df_daily, investigate seasonal trends by grouping data by month, analyze significant changes over time using rolling averages, and explore regional differences in consumption.
"""

import matplotlib.pyplot as plt

# 1. Correlation Analysis
correlation_matrix = df_daily.corr()
display(correlation_matrix)

# 2. Seasonal Trends
df_daily['Month'] = df_daily['Date'].dt.month
monthly_consumption = df_daily.groupby(['Région', 'Month'])['TotalConsommationRegion'].mean().unstack()
monthly_consumption.plot(figsize=(12, 6))
plt.xlabel('Month')
plt.ylabel('Average Total Consumption (MW)')
plt.title('Seasonal Trends in Energy Consumption by Region')
plt.legend(title='Region')
plt.show()


# 3. Significant Changes Over Time (Rolling Average)
for region in df_daily['Région'].unique():
    region_data = df_daily[df_daily['Région'] == region].copy()
    region_data['Rolling_Mean'] = region_data['TotalConsommationRegion'].rolling(window=30).mean()
    plt.figure(figsize=(12, 6))
    plt.plot(region_data['Date'], region_data['TotalConsommationRegion'], label='Daily Consumption')
    plt.plot(region_data['Date'], region_data['Rolling_Mean'], label='30-Day Rolling Average')
    plt.xlabel('Date')
    plt.ylabel('Total Consumption (MW)')
    plt.title(f'Total Consumption and Rolling Average for {region}')
    plt.legend()
    plt.show()


# 4. Regional Differences
regional_stats = df_daily.groupby('Région')['TotalConsommationRegion'].agg(['mean', 'std'])
display(regional_stats)
regional_stats.plot(kind='bar', figsize=(10,6), subplots=True)
plt.tight_layout()
plt.show()

"""**Reasoning**:
The error "ValueError: could not convert string to float: 'Auvergne-Rhône-Alpes'" indicates that the 'Région' column, which is a string, is causing issues during the correlation calculation.  The correlation method should only be applied to numerical columns.  We need to exclude the 'Région' and 'Date' columns and any other non-numeric columns from the correlation analysis.


"""

import matplotlib.pyplot as plt

# 1. Correlation Analysis
numeric_cols = df_daily.select_dtypes(include=['number']).columns
correlation_matrix = df_daily[numeric_cols].corr()
display(correlation_matrix)

# 2. Seasonal Trends
df_daily['Month'] = df_daily['Date'].dt.month
monthly_consumption = df_daily.groupby(['Région', 'Month'])['TotalConsommationRegion'].mean().unstack()
monthly_consumption.plot(figsize=(12, 6))
plt.xlabel('Month')
plt.ylabel('Average Total Consumption (MW)')
plt.title('Seasonal Trends in Energy Consumption by Region')
plt.legend(title='Region')
plt.show()


# 3. Significant Changes Over Time (Rolling Average)
for region in df_daily['Région'].unique():
    region_data = df_daily[df_daily['Région'] == region].copy()
    region_data['Rolling_Mean'] = region_data['TotalConsommationRegion'].rolling(window=30).mean()
    plt.figure(figsize=(12, 6))
    plt.plot(region_data['Date'], region_data['TotalConsommationRegion'], label='Daily Consumption')
    plt.plot(region_data['Date'], region_data['Rolling_Mean'], label='30-Day Rolling Average')
    plt.xlabel('Date')
    plt.ylabel('Total Consumption (MW)')
    plt.title(f'Total Consumption and Rolling Average for {region}')
    plt.legend()
    plt.show()


# 4. Regional Differences
regional_stats = df_daily.groupby('Région')['TotalConsommationRegion'].agg(['mean', 'std'])
display(regional_stats)
regional_stats.plot(kind='bar', figsize=(10,6), subplots=True)
plt.tight_layout()
plt.show()

"""## Summary:

### 1. Q&A

No explicit questions were posed in the data analysis task. However, the analysis implicitly seeks to answer questions like:

* What are the correlations between different energy sources and total consumption?
* Are there seasonal trends in energy consumption across different regions?
* Are there any significant changes or outliers in energy consumption over time?
* How does energy consumption vary across different regions?


### 2. Data Analysis Key Findings

* **High Correlation between Total Consumption and Specific Energy Sources:** The correlation analysis revealed relationships between total energy consumption and contributions from individual sources (e.g., Nuclear, Thermal).  The exact correlation values are not explicitly stated in the summary but are present in the generated correlation matrix.

* **Clear Seasonal Trends in Energy Consumption:** The analysis of monthly averages shows distinct seasonal patterns in energy consumption across different regions.  Higher consumption during colder months is likely.

* **Regional Consumption Differences:**  The analysis demonstrates variations in average energy consumption and its variability across different French regions.  The `regional_stats` table in the analysis provides the mean and standard deviation for each region.


### 3. Insights or Next Steps

* **Investigate Correlation Drivers:** Further investigate the strong correlations observed between total consumption and specific energy sources. Determine the causal relationships and factors driving these correlations.

* **Model Seasonal Variations:** Develop a time series model to predict energy consumption based on seasonal patterns and potentially external factors (weather, economic activity).

"""

from google.colab import drive
drive.mount('/content/drive')

"""# Task
Télécharger

Here is all the data you need:
"eco2mix-regional-cons-def.csv"

## Data loading

### Subtask:
Load the "eco2mix-regional-cons-def.csv" file into a pandas DataFrame.
"""